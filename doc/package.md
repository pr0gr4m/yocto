# package

### 지원 가능한 패키지 형식

비트베이크는 다음과 같은 4개의 패키지 형식을 지원한다.
* RPM : 레드햇 패키지 매니저
* DEB : 데비안 패키지 매니어
* IPK : Itsy Package Management System으로 DEB을 닮은 경량화 패키지 관리 시스템
* TAR : 타르볼 파일 유형

패키지 형식들에 대한 지원은 package_rpm, package_deb, package_ipk같은 클래스를 다음과 같이 지정하여 사용한다.
```bash
PACKAGE_CLASSES ?= "package_rpm package_deb package_ipk"
```
이는 예를 들어 build/conf/local.conf 파일에 설정해 적용할 수 있다. PACKAGE_CLASSES변수를 이용하여 패키지들을 하나 이상의 형식으로 생성할 수 있다. 참고로 poky의 기본 설정은 RPM 패키지 형식으로 DNF 패키지 매니저를 이용한다.

### 패키지 설치 코드

패키지 설치와 삭제 과정에서 다음과 같은 스크립트를 사용할 수 있다.
* preinst : 패키지가 압축 해제되기 전에 실행된다. 서비스들은 설치나 업그레이드를 위해 preinst가 실행되기 전에 멈춰져야 한다.
* postinst : 패키지가 압축 해제된 후에 필요한 환경설정을 한다. 상당수의 내용이 패키지가 설치되거나 업그레이드된 후에 서비스를 재시작하는 명령어를 실행한다.
* prerm : 보통 패키지와 관련된 daemon을 정지한다. 패키지와 관련된 파일이 지워지기 전에 실행된다.
* postrm : 주로 패키지에 의해 생성된 파일이나 링크를 수정한다.

postinst는 루트 파일시스템 생성 시 실행된다. 스크립트가 성공적으로 진행되면 패키지는 installed으로 표시된다. 스크립트가 실패하면 패키지는 unpacked으로 표시된다. unpacked 상태인 모든 패키지는 이미지가 처음 부팅되고 난 후 스크립트를 다시 실행하게 된다.
postinst 스크립트를 추가하려면 다음과 같은 코드를 작성한다.
```bash
pkg_postinst_${PN} () {
    #!/bin/sh -e
    # commands
}
```
패키지 이름을 사용하는 대신 이를 자동으로 할당하는 PN 변수를 사용할 수 있다.
스크립트의 실행을 미뤄 타깃 디바이스에서 실행하도록 다음과 같은 구조의 스크립트를 사용한다.
```bash
pkg_postinst_${PN} () {
    #!/bin/sh -e
    if [ -n "$D" ]; then
        # commands
    else
        exit 1
    fi
}
```
변수 $D가 값을 갖고 있다면 이 스크립트는 에러를 반환하고 패키지는 unpacked 상태가 된다. 즉, if 구문에 작성된 문장은 변수 $D가 할당되지 않았을 때만 실행된다.

다음과 같이 포스트스크립트의 실행을 건너뛰어 rootfs를 만드는 시점에 데몬이 실행되는 것을 막고 업그레이드가 완료된 이후에 실행하게 할 수도 있다.
```bash
pkg_postinst_${PN} () {
    #!/bin/sh -e
    if [ -n "$D" ]; then
        exit 0
    else
        # commands
    fi
}
```

IMAGE_FEATURES에서 이미지를 read-only-rootfs로 만들 경우 모든 postinst 스크립트는 성공해야 한다. 어떤 스크립트가 실패하고 패키지를 unpacked 상태로 표기해 루트 파일시스템 생성 이후에 돌아가게 된다면 do_rootfs 태스크는 실패한다.

postinst 스크립트를 작성하는 데 가장 많이 하는 실수는 절대 경로 앞에 변수 $D를 생략하는 것이다. 이렇게 하면 경로가 호스트와 타깃 환경 모두 유효하게 된다. D 변수가 비어 있는지 확인하면 어떤 환경 변수가 사용됐는지 판별하고, 루트 파일시스템이 생성되거나 타깃에서 실행되고 있으면 다른 코드를 사용할 수 있다.
또 다른 실수는 타깃 아키텍처에 관련되거나 종속적인 프로세스를 실행하려 하는 것이다. 이 경우엔 타깃 스크립트의 실행을 미뤄서 해결할 수 있다.

### shared state cache

poky의 기본 동작은 비트베이크에 특정 레시피를 지정하지 않으면 모든 것을 처음부터 빌드한다. 이 방식은 안정적이지만 시간이 오래 걸린다.
poky는 비트베이크가 생성한 빌드 메타데이터나 체크섬 등의 정보를 이용해 태스크의 스냅샷을 저장한다. 이 패키지로 묶인 캐시 정보를 셰어드 스테이트 캐시(sstate-cache)라고 한다. 이 캐시는 SSTATE_DIR 디렉토리에 저장되고 패키지로 묶인 태스크의 결과를 포함한다. 비트베이크가 태스크를 실행하려 할 때 먼저 일치하는 sstate-cache 패키지가 있는지 확인한다. 패키지가 존재하면 빌드하지 않고 이미 빌드된 패키지를 이용한다.
poky로 여러 빌드를 한 번에 진행중이라면 sstate-cache가 빌드할 떄마다 커지기 때문에 다음과 같은 명령으로 중복된 데이터나 오래된 데이터를 제거하는 것이 좋다.
```console
$ ./scripts/sstate-cache-management.sh --remove-duplicated -d --cachedir=<path to sstate-cached>
```

### 패키지 버전 선택

poky는 기본적으로 프레퍼런스를 이용해 명시적으로 선언하지 않는 한 최신 버전의 패키지를 이용한다. 예를 들어 myrecipe_1.0.bb와 myrecipe_1.2.bb 두 개의 레시피가 있다면 기본 동작으로 1.2 버전의 레시피를 빌드한다.
레시피에서 패키지 변수를 나타내는 PV 변수와 함께 버전을 구성하는 PE(Package Epoch)와 PR(Package Revision) 변수가 있다.
PE 변수는 기본 값으로 0을 사용하고 패키지 버전 정책이 바뀌어 일반적인 버전 순서를 깨뜨릴 수 있을 때 이용한다. 예를 들어 패키지가 PV 변수 값에 2012, 2015와 같이 연도를 이용하다가 정책이 바뀌어 1.0으로 릴리즈한다고 가정하면 둘 중 어느 것이 최신 버전인지 구분할 수 없다. 여기서 PE="1"을 사용하면 1.0이 2015보다 높다고 표시할 수 있다.
PR 변수는 기본 값으로 r0을 사용하고 버전을 정하는 과정에서 사용된다. 이 변수가 업데이트되면 비트베이크에게 특정 레시피에 대해 모두 재빌드하라고 강제한다.

### 런타임 패키지 의존성

대부분 레시피의 최종 결과물은 패키지 관리자가 관리하는 패키지다. 패키지들 사이에는 서로 의존성이 있을 수 있기에 이런 것들을 표현할 여러 패키지 제약 조건이 있다. 이런 제약 조건은 패키지 형식에 따라 다르기 때문에 비트베이크는 패키지 제약 조건을 추상화하는 데 사용하는 메타데이터 집합을 갖고 있다. 다음은 런타임 제약 조건에서 많이 사용하는 변수다.
* RDEPENDS : 특정 패키지를 설치할 때 함께 설치해야 할 필요가 있는 패키지 목록을 정의한다.
* RPROVIDES : 패키지 이름의 별칭을 정의한다.
* RCONFLICTS : 특정 패키지와 충돌하는 것으로 알려진 패키지 목록을 정의한다. 이 패키지들 중 하나만 설치할 수 있다.
* RREPLACES : 특정 패키지의 대안으로 사용할 수 있는 패키지 이름을 정의한다.

### 패키지 피드

do_rootfs는 루트 파일시스템을 만들 때 로컬 패키지 저장소를 사용해서 바이너리 패키지를 다운로드한다. 이 저장소를 패키지 피드(Package Feed)라고 한다.
이 저장소는 주로 이미지나 SDK를 빌드할 때 사용하는데, 프로젝트 내부에서 원격으로 접속할 수 있게 하거나 외부에 공개할 수도 있다. 패키지 피드는 다음과 같은 특징을 갖는다.
* 개발 단계에서 업데이트된 애플리케이션에 대해 재설치 없이 쉽게 테스트할 수 있게 한다.
* 추가 패키지를 실행하는 이미지를 업데이트할 수 있게 한다.
* 현장에서 상품을 업데이트한다.

패키지 피드의 안정성을 확보하기 위해 패키지가 변경될 때마다 PR을 증가시켜야 한다. 이에 관한 것은 Yocto 프로젝트가 PR 서비스로 제공한다. 비트베이크의 일부인 PR 서비스는 수작업 없이 비트베이크가 레시피의 체크섬이 바뀔 때마다 PR을 자동으로 증가시켜주기 위해 사용된다.
이미지를 만들기 위해 poky를 사용하면서 원격 패키지 피드를 사용하지 않으면 PR 서비스는 필요 없다. 비트베이크가 태스크의 체크섬이 바뀌면 스스로 재빌드하기 때문이다.
기본적으로 PR 서비스는 활성하돼 있지 않다. 로컬에서 이를 활성화시키려면 PRSERV_HOST 변수를 비트베이크 환경설정 파일에 설정해야 한다. 예를 들어 build/conf/local.conf에 다음과 같이 설정한다.
```bash
PRSERV_HOST = "localhost:0"
```
빌드가 하나의 컴퓨터에서 이뤄질 때에는 패키지 피드의 모든 패키지를 빌드하는 데는 이 방법으로 충분하다. 여러 컴퓨터가 공통 패키지 피드를 갖고 작업하는 더 복잡한 경우에는 패키지 피드에 관련된 하나의 PR 서비스를 모든 빌드 머신이 이용하게 설정해야 한다. 이 경우에는 다음과 같이 PR 서비스를 bitbake-prserv 명령어로 실행한다.
```console
$ bitbake-prserv --host <ip> --port <port> --start
```
서버를 시작하는 것 외에도 모든 빌드 서버의 비트베이크 환경설정 파일의 PRSERV_HOST 변수에 서버의 IP와 포트 번호를 적어 서버를 사용하게 해야 한다.

### 패키지 피드 사용

패키지 피드를 사용하려면 다음과 같은 두 가지가 적용돼야 한다.
* 패키지에 대해 접근을 제공하는 서버
* 서버에 접근해서 패키지를 다운로드할 수 있는 클라이언트

패키지 피드에 의해 제공되는 패키지들을 레시피에 따라 빌드한 후, 패키지 피드를 제공하기 위해 피키지의 인덱스를 다음 명령어를 통해 만들어야 한다.
```console
$ bitbake package-index
```

패키지는 build/tmp/deploy 디렉토리에 있는 것을 사용한다. 선택한 패키지 형식에 따라 각 하위 디렉토리를 선택한다. 기본적으로 poky는 RPM을 사용하기 때문에 build/tmp/deploy/rpm 디렉토리의 패키지를 사용한다.
패키지와 같이 패키지 인덱스는 HTTP 같은 전송 프로토콜을 사용할 수 있어야 한다. 이를 위해 Apache, Nginx 등의 서버를 사용할 수 있다. 로컬 개발에서 HTTP로 패키지를 사용할 수 있는 편리한 방법은 다음과 같은 간단한 파이썬 서버를 사용하는 것이다.
```console
$ cd build/tmp/deploy/rpm
$ python3 -m http.server 5678
```

패키지 관리자를 이미지에 추가하기 위해 EXTRA_IMAGE_FEATURE 변수에 package-management를 추가하고 PACKAGE_FEED_URIS 변수에 패키지를 다운로드할 URI를 설정한다. 예를 들어 build/conf/local.conf에 다음을 추가한다.
```bash
PACKAGE_FEED_URIS = "http://my-ip:5678"
EXTRA_IMAGE_FEATURES += " package-management "
```
패키지 관리자 지원 없이 작은 이미지를 빌드하려면 EXTRA_IMAGE_FEATURES변수에 package-management를 포함시키지 말아야 한다. 위 설정은 클라이언트에서 돌아가는 이미지가 서버에 접근해 패키지들을 설치, 제거, 업그레이드할 수 있게 해준다.
이 과정 후에 타깃 디바이스에서 런타임 패키지 관리자를 사용할 수 있다. 예를 들어 RPM 형식의 패키지를 선택했다면 저장소의 정보를 다음 명령으로 찾은 후, 패키지를 찾고 설치할 수 있다.
```console
$ dnf check-update
$ dnf search <package>
$ dnf install <package>
```